<html>
<head>
    <title>Kadena Transfer Tool</title>
    <link rel="icon" href="/kadena-logo-64px.png">
    <script src="https://code.jquery.com/jquery-3.1.1.min.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pact-lang-api@4.1.2/pact-lang-api-global.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script>
      //Form Validation
     $(document).ready(function(){

       // custom form validation rule
       $.fn.form.settings.rules.validSig = function(sig) {
         if (sig.length === 128 && !isPriv(sig)) {
           return validateSig(sig);
         }
         else return true;
       };

       $.fn.form.settings.rules.validPriv = function(sig) {
         if (sig.length === 128 && isPriv(sig)){
           return validatePriv(sig.slice(0,64))
         } else if (sig.length === 64) {
           return validatePriv(sig);
         }
         else return true;
       };

        $.fn.form.settings.rules.validEntry = function(sig) {
          if (sig.length === 128 || sig.length === 64) {
            return true;
          } else if (sig.length === 0){
            if (document.getElementById("hash-string").innerText === ""){
              return true;
            } else return false;
          }
          else return false;
        };

       $.fn.form.settings.rules.checkKeyLength= function(key) {
         if (document.getElementById("receiver-select").hidden === false){
           if (document.getElementById("basic").classList.contains( 'active' )){
             return key.length===64;
           }
           else return true;
         }
         else {
           return true;
         }
       };

       $.fn.form.settings.rules.checkCustomKeyLength= function(guard) {
       if (document.getElementById("custom").classList.contains('active')){
          guard = JSON.parse(guard);
          if (guard.keys.length === 0) return false;
          let validKey = guard.keys.filter(key => {
            return key.length===64;
          })
          return validKey.length === guard.keys.length;
        } else return true;
      }

       $.fn.form.settings.rules.checkPredicate = function(key) {
         if (document.getElementById("receiver-select").hidden === false){
           if (document.getElementById("custom").classList.contains( 'active' )){
              let guard = JSON.parse(document.getElementById("custom-guard").value);
              return (guard.pred === "keys-all" || guard.pred === "keys-any" || guard.pred === "keys-2");
           } else return true;
         }
         else {
           return true;
         }
       };

       $.fn.form.settings.rules.checkKeyset = function(keyset) {
         if (document.getElementById("receiver-exist").hidden === false){
           keyset = JSON.parse(keyset)
           if (validateKeyset(keyset)) return true;
           else if (!!keyset.keysetref) return true;
           else return false;
         } else return true;
       }

       $('#kadena-form')
         .form({
           on: 'blur',
           fields: {
             server: {
               identifier  : 'server',
               rules: [
                 {
                   type   : 'empty',
                   prompt : 'Please enter a node server'
                 }
               ]
             },
             signature: {
               identifier  : 'signature',
               rules: [
                 {
                   type   : 'validSig',
                   prompt : 'Signature is invalid. Please check again'
                 },
                 {
                   type   : 'validPriv',
                   prompt : 'Private Key is invalid. Please check again'
                 },
                 {
                   type   : 'validEntry',
                   prompt : 'Length does not match a Private key or a Signature. Please check again'
                 }
               ]
             },
             fromAccount: {
               identifier  : 'fromAccount',
               rules: [
                 {
                   type   : 'minLength[3]',
                 },
                 {
                   type   : 'maxLength[256]',
                 }
               ]
             },
             toAccount: {
               identifier  : 'toAccount',
               rules: [
                 {
                   type   : 'maxLength[256]',
                 },
                 {
                   type   : 'minLength[3]',
                 }
               ]
             },
             toAccountPublicKey: {
               identifier : 'basicPublicKey',
               rules : [
                 {
                   type: 'checkKeyLength',
                   prompt: 'Length does not match a Public Key'
                 },
                 {
                   type: 'checkPredicate',
                   prompt: 'Keyset Predicate is Invalid'
                 }
               ]
             },
             toAccountGuard: {
               identifier : 'custom-guard',
               rules : [
                 {
                   type: 'checkCustomKeyLength',
                   prompt: 'Length does not match a Public Key'
                 },
                 {
                   type: 'checkPredicate',
                   prompt: 'Keyset Predicate is Invalid'
                 }
               ]
             },
             existingGuard: {
               identifier : 'receiver-keyset-fixed',
               rules : [
                 {
                   type: 'checkKeyset',
                   prompt: 'Transferring to the receiver is not supported.'
                 }
               ]
             },
             amount: {
               identifier  : 'amount',
               rules: [
                 {
                   type   : 'decimal[<0]',
                 }
               ]
             }
           },
           inline : true,
           onSuccess(e){
             e.preventDefault();
             const {fromAccount, toAccount, fromChainId, toChainId} = getInputs();
             if (!isCrossChain(fromChainId, toChainId) && (fromAccount === toAccount)){
               setError("Sender Account is the Receiver Account")
             } else {
               clearError();
               if (formIsValid() && document.getElementById("signature").value.length !== 0){
                 submit();
                 document.getElementById('submit-button').classList.add("disabled");
                 document.getElementById('reset-button').classList.add("disabled");
               }
             }
           }
         });

      //Activate Menu
      $('.ui.secondary.pointing.menu').on('click', ".item", function(e) {
         $('.ui .item').removeClass('active');
         $(this).addClass('active');
         $(`.ui .segment .field`).attr("hidden", true)
         $(`.ui .segment #${e.target.id}-input`).attr("hidden", false)
       });

       //Activate Dropdown
       $('.dropdown')
         .dropdown();

       $('.message .close')
         .on('click', function() {
           $(this)
             .closest('.message')
             .transition('fade')
           ;
         })
       ;
     });

     const mkReq = (cmd) => {
         return {
             headers: {
                 "Content-Type": "application/json"
             },
             method: "POST",
             body: JSON.stringify(cmd)
         };
     };

     // INITIATION FUNCTIONS
     window.addEventListener('load', function (event) {
       document.getElementById("fromAccount").addEventListener("blur", async function(e){
         fetchSenderKeyset();
       })

       document.getElementById("network-0").addEventListener("click", async function(e){
         reset();
       })

       document.getElementById("network-1").addEventListener("click", async function(e){
         reset();
       })

       document.getElementById("fromChainId").addEventListener("change", async function(e){
         fetchSenderKeyset();
         showXWarning()
       })

       document.getElementById("toChainId").addEventListener("change", async function(e){
         fetchReceiverKeyset();
         showXWarning()
       })

       document.getElementById("toAccount").addEventListener("blur", async function(e){
         fetchReceiverKeyset();
       })

       document.getElementById("sign-button").addEventListener("click",  function(event){
         const {fromChainId, toChainId, fromAccount, toAccount} = getInputs();
         if (formIsValid()){
           if (document.getElementById("publicKey").value===""){
              setError("Sender is not valid")
           } else if (document.getElementById("sign-button").classList.contains('active')){
             closeAccordion();
           } else if (!isCrossChain(fromChainId, toChainId) && (fromAccount === toAccount)){
             setError("Sender Account is the Receiver Account")
           } else {
             showHash();
           }
         }
       })

     document.getElementById("reset-button").addEventListener("click", function(event){
       reset();
     })

     });

     const localGasLimit = 1000
     const transferGasLimit = 2300;
     const xChainInitiateGasLimit = 1800;
     const xChainFinishGasLimit = 750;
     const xChainFinishGasPrice = 0.00000001;
     const gasPrice = 0.00001;

     function formIsValid(){
       return $('.form').form('is valid');
     }

     function reset(){
       clearError()
       $('.form').form('reset');
       closeAccordion()
       enableFields()
       document.getElementById("receiver-keyset").hidden = true;
       document.getElementById("receiver-exist").hidden = true;
       document.getElementById("receiver-select").hidden = true;
       document.getElementById("receiver-keyset-fixed").value = null;
     }

    function showXWarning(){
      let bool;
      let {fromChainId, toChainId} = getInputs();
      bool = isCrossChain(fromChainId, toChainId);
      if (bool){
        document.getElementById('xchain-box').classList.remove("hidden")
        document.getElementById("x-header").innerHTML = "You're about to make a Cross Chain Transfer.";
        document.getElementById("x-message").innerHTML = "This process will take about 4 minutes, and may result in an unfinished transaction depending on network error or the state of gas station. Please keep the requestKey for further processing wait until the transaction finishes.";
      }
      else {
        document.getElementById("xchain-box").classList.add("hidden");
        document.getElementById("x-header").innerHTML = "";
        document.getElementById("x-message").innerHTML = "";
      }
    }

     function getNode(chainId) {
       let apiHost = (node, networkId, chainId) => `https://${node}/chainweb/0.0/${networkId}/chain/${chainId}/pact`;
       if (document.getElementById("network").innerText === "Mainnet") {
         return {
           host : apiHost("api.chainweb.com", "mainnet01", chainId),
           networkId: "mainnet01"
         }
       } else if (document.getElementById("network").innerText === "Testnet") {
         return {
           host : apiHost("api.testnet.chainweb.com", "testnet04", chainId),
           networkId: "testnet04"
         }
       } else {
         console.log(JSON.stringify(document.getElementById("network").innerText))
       }
     }

     function getNetwork() {
       if (document.getElementById("network").innerText === "Mainnet") {
         return "mainnet";
       } else if (document.getElementById("network").innerText === "Testnet") {
         return "testnet";
       } else {
         console.log(JSON.stringify(document.getElementById("network").innerText))
       }
     }

     async function wait(ms = 1000) {
       return new Promise(resolve => {
         setTimeout(resolve, ms);
       });
     }

     async function submit() {
       clearError();
       let cmd = document.getElementById("cmd").value
       let sig = document.getElementById("signature").value;

       //Sign with signature
       let apiHost = getNode(document.getElementById("fromChainId").value).host
       let targetHost = getNode(document.getElementById("toChainId").value).host
       let networkId=getNode(document.getElementById("toChainId").value).networkId
       //Sign with Private Key
       if (isPriv(sig)) {
         cmd = getTransferCmd();
         closeAccordion()
       }
       //Sign with Signature
       else if (!isPriv(sig)) cmd = signCmd(cmd, sig);
       const txRes = await fetch(`${apiHost}/api/v1/send`, mkReq(cmd))

       document.getElementById('status-box').classList.remove("hidden")
       //Fetch succeeded
       if (txRes.ok) {
           let res = await txRes.json();
           document.getElementById('status-lookup').hidden = true;
           document.getElementById('status-header').innerHTML = "Waiting for response...";
           document.getElementById('status-message').innerText = JSON.stringify(res.requestKeys[0]);
           fetch(`${apiHost}/api/v1/listen`, mkReq({"listen": res.requestKeys[0]}))
           .then(res =>{
             return res.json()
           })
           .then(async res => {
             if (res.result.status==="failure"){
               document.getElementById('status-header').innerHTML = "Transfer Failed";
               document.getElementById('status-message').innerText = JSON.stringify(res.result.error);
               document.getElementById('status-lookup').hidden = false;
               document.getElementById('status-link').innerText = res.reqKey;
               document.getElementById('status-link').href = getLink(res.reqKey);
             } else {
               //Check if crosschain
               if (res.continuation){
                 //send proof

                 const pactId = res.continuation.pactId;
                 document.getElementById('status-message').innerHTML ="Initiated from the Source Chain: " + "<br />" +  JSON.stringify(pactId) + "<br />" + "<br />" + "Waiting for Proof...";
                 const targetChainId = res.continuation.yield.provenance.targetChainId;
                 const spvCmd = {"targetChainId": targetChainId, "requestKey": pactId };
                 let proof;
                 while (!proof){
                   await wait(2500);
                   const res = await fetch(`${apiHost}/spv`, mkReq(spvCmd));
                   let foo = await res;
                   if (foo.ok){
                     proof = await res.json();
                   }
                 }
                 const m = Pact.lang.mkMeta("kadena-xchain-gas", targetChainId, xChainFinishGasPrice, xChainFinishGasLimit, createTime(), 28800);
                 const contCmd = {type: "cont", keyPairs:[],pactId: pactId, rollback: false, step: 1, meta: m, proof: proof, networkId: networkId}
                 const cmd = Pact.simple.cont.createCommand( contCmd.keyPairs, contCmd.nonce, contCmd.step, contCmd.pactId,
                                                          contCmd.rollback, contCmd.envData, contCmd.meta, contCmd.proof, contCmd.networkId);
                 fetch(`${targetHost}/api/v1/send`, mkReq(cmd))
                 .then(async txRes => {
                   if (txRes.ok) {
                     let res = await txRes.json();
                     document.getElementById('status-lookup').hidden = true;
                     document.getElementById('status-header').innerHTML = "Waiting for response...";
                     document.getElementById('status-message').innerHTML ="Initiated from the Source Chain: " + "<br />" +  JSON.stringify(pactId) + "<br />" + "<br />" + "Receiving from the Target Chain: " + "<br />" + JSON.stringify(res.requestKeys[0]);
                     fetch(`${targetHost}/api/v1/listen`, mkReq({"listen": res.requestKeys[0]}))
                     .then(res =>{
                       return res.json();
                     })
                     .then(async res => {
                       if (res.result.status==="failure"){
                         document.getElementById('status-header').innerHTML = "Transfer Failed";
                         document.getElementById('status-message').innerText = JSON.stringify(res.result.error);
                         document.getElementById('status-lookup').hidden = false;
                         document.getElementById('status-link').innerText = res.reqKey;
                         document.getElementById('status-link').href = getLink(res.reqKey);
                       } else {
                         document.getElementById('status-header').innerHTML = "Transfer Succeeded";
                         document.getElementById('status-message').innerText = JSON.stringify(res.result.data);
                         document.getElementById('status-lookup').hidden = false;
                         document.getElementById('status-link').innerText = res.reqKey;
                         document.getElementById('status-link').href = getLink(res.reqKey);
                       }
                     })
                   } else {
                   let res = await txRes.text();
                   document.getElementById('status-header').innerHTML = "Request Failed.";
                   document.getElementById('status-message').innerText = res;
                   document.getElementById('status-lookup').hidden = true;
                 }})
               } else {
                 document.getElementById('status-header').innerHTML = "Transfer Succeeded."
                 document.getElementById('status-message').innerText = JSON.stringify(res.result.data);
                 document.getElementById('status-lookup').hidden = false;
                 document.getElementById('status-link').innerText = res.reqKey;
                 document.getElementById('status-link').href = getLink(res.reqKey);
               }
             }
           })
         } else {
           let res = await txRes.text();
           document.getElementById('status-header').innerHTML = "Request Failed";
           document.getElementById('status-message').innerText = res;
           document.getElementById('status-lookup').hidden = true;
         }
         return (false);
     };

     let getLink = (reqKey) => `https://explorer.chainweb.com/${getNetwork()}/tx/${reqKey}`;

     async function fetchSenderKeyset(){
       const chainId = document.getElementById("fromChainId").value;
       const account = document.getElementById("fromAccount").value;
       checkPublicKey(account, chainId).then(res => {
         if (!res) {}
         else if (res.result.status==="failure" && res.result.error.message.slice(0,24)==="with-read: row not found") {
           document.getElementById("publicKey").value = ""
           setError("Sender does not exist")
         } else {
           if (res.result.data.guard.keysetref) {
             getKeysetRef(res.result.data.guard.keysetref, getNode(chainId).host).then(resKeyset => {
               let publicKey = resKeyset.result.data.keys
               document.getElementById("publicKey").value = publicKey
               clearError();
             });
           } else if (res.result.data.guard.keys){
             let publicKey = res.result.data.guard.keys
             document.getElementById("publicKey").value = publicKey
             clearError();
           } else if (("fun" in res.result.data.guard) && ("args" in res.result.data.guard)) {
             // Adds support for a very specific format of time locked accounts
             const guardFun = res.result.data.guard.fun;
             const [ksRef,afterDateFun] = res.result.data.guard.args;
             if ((guardFun === "util.guards.enforce-and") && ("keysetref" in ksRef) && (afterDateFun["fun"] === "util.guards.enforce-after-date" )) {
               getKeysetRef(ksRef.keysetref, getNode(chainId).host).then(resKeyset => {
               let publicKey = resKeyset.result.data.keys
               document.getElementById("publicKey").value = publicKey
               clearError();
             });
             } else {
              setError("Account Guard of the sender is not conventional. Please use a different tool.")
             }
           } else {
             setError("Account Guard of the sender is not conventional. Please use a different tool.")
           }
         }
       })
     }

     async function fetchReceiverKeyset(){
       const chainId = document.getElementById("toChainId").value;
       const account = document.getElementById("toAccount").value;
       checkPublicKey(account, chainId).then(res => {
         if (!res) {}
         else if (res.result.status==="failure" && res.result.error.message.slice(0,24)==="with-read: row not found") {
           document.getElementById("receiver-keyset").hidden = false;
           document.getElementById("receiver-exist").hidden = true;
           document.getElementById("receiver-select").hidden = false;
           document.getElementById("receiver-keyset-fixed").value = null;
        } else {
           document.getElementById("receiver-keyset").hidden = false;
           document.getElementById("receiver-select").hidden = true;
           document.getElementById("receiver-exist").hidden = false;
           document.getElementById("receiver-keyset-fixed").value = JSON.stringify(res.result.data.guard, undefined, 2);
         }
       })
     }

   const convertDecimal = (decimal) => {
     decimal = decimal.toString();
     if (decimal.includes('.')) { return decimal }
     if ((decimal / Math.floor(decimal)) === 1) {
       decimal = decimal + ".0"
     }
     return decimal
   }

   const createTime = () =>  Math.round((new Date).getTime()/1000)-60;

   function setError(msg) {
     document.getElementById("kadena-form").classList.add("error")
     document.getElementById("acct-err").hidden=false;
     document.getElementById("acct-err").innerText = msg;
   }

   function clearError (){
     document.getElementById("kadena-form").classList.remove("error")
     document.getElementById("acct-err").hidden=true;
     document.getElementById("acct-err").innerText = "";
   }

   var decodeBase64 = function(s) {
     validateBase64(s);
     var i, d = atob(s), b = new Uint8Array(d.length);
     for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
     return b;
   };

   function decode(s) {
     return  s.replace(/-/g, '+')
                 .replace(/_/g, '/')+"=";
   }
   function validateBase64(s) {
     if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
       throw new TypeError('invalid encoding');
     }
   }

   function isPriv(sig){
     if (sig.length === 64) return true;
     let secretKey = sig.slice(0,64);
     let publicKey = sig.slice(64);
     let restored = Pact.crypto.restoreKeyPairFromSecretKey(secretKey);
     if (restored.secretKey === secretKey && restored.publicKey === publicKey) return true;
     else return false
   }

   function validatePriv(priv){
      try {
        if (!Pact.crypto.restoreKeyPairFromSecretKey(priv)) {
          return false;
        } else {
          let cmd = getTransferCmd();
          let hash = decode(cmd.cmds[0].hash);
          let sig = cmd.cmds[0].sigs[0].sig;
          let pubKey = document.getElementById("publicKey").value;
          try {
            let verified = pubKey.filter(key => {
              return nacl.sign.detached.verify(decodeBase64(hash),Pact.crypto.hexToBin(sig), Pact.crypto.hexToBin(key));
            })
            if (verified.length>0){
              return true;
            } else return false;
          } catch {
           return false
          }
        }
       } catch {
         return false
       }
   }

   function validateSig (sig) {
     let hash = document.getElementById("hash-string").innerText;
     hash = decode(hash)
     let pubKey = document.getElementById("publicKey").value;
     try{
       let verified = pubKey.filter(key => {
         return nacl.sign.detached.verify(decodeBase64(hash),Pact.crypto.hexToBin(sig), Pact.crypto.hexToBin(key));
       })
      if (verified.length>0){
        return true;
      } else return false;
    } catch(e){
      return false;
    }
   }

   async function getAccountDetails(account, node){
     if (account.length>=3){
       try {
         const m = Pact.lang.mkMeta("", "", gasPrice, localGasLimit, createTime(), 28800);
         const tx = await Pact.fetch.local({
           pactCode: `(coin.details ${JSON.stringify(account)})`,
           meta: m
         }, node)
         return tx;
       } catch(e){
         throw(e)
       }
     } else{
       return false;
     }
   }

    async function getKeysetRef(keyset, node){
      try {
        const m = Pact.lang.mkMeta("", "", gasPrice, localGasLimit, createTime(), 28800);
        const tx = await Pact.fetch.local({
          pactCode: `(describe-keyset ${JSON.stringify(keyset)})`,
          meta: m
        }, node)
        return tx;
      } catch(e){
        throw(e)
      }
    }

   async function checkPublicKey (account, chainId) {
     let node = getNode(chainId).host;
     return getAccountDetails(account, node);
   }

   function validateKeyset (keyset){
     try {
       const {pred, keys} = keyset;
       let preds = [
         "keys-all",
         "keys-any",
         "keys-2"
       ]
       let validKeys = keys.filter(keys=> keys.length===64).length === keys.length;
       let validPred = preds.includes(pred);
       return validKeys && validPred;
     } catch {
       return false;
     }
   }

  function crossTransfer(sender, receiver, receiverKp, srcChain, targetChain, amount, fromPub, fromPriv){
    const m = Pact.lang.mkMeta(sender, srcChain, gasPrice, xChainInitiateGasLimit, createTime(), 28800);
    const kp = fromPub.map(pub => {
      return {publicKey: pub, secretKey: fromPriv, clist: [{name: "coin.GAS", args: []}, {name: "coin.TRANSFER_XCHAIN", args: [sender, receiver, {"decimal": amount}, targetChain]}]}
    })
    let pactCode = `(coin.transfer-crosschain ${JSON.stringify(sender)} ${JSON.stringify(receiver)} (read-keyset "ks") ${JSON.stringify(targetChain)} ${convertDecimal(amount)})`;
    if (!validateKeyset(receiverKp) && receiverKp.keysetref){
      pactCode = `(coin.transfer-crosschain ${JSON.stringify(sender)} ${JSON.stringify(receiver)} (keyset-ref-guard ${JSON.stringify(receiverKp.keysetref)}) ${JSON.stringify(targetChain)} ${convertDecimal(amount)})`;
    }

    return Pact.simple.exec.createCommand(
      kp,
      JSON.stringify(new Date()),
      pactCode,
      {"ks": receiverKp},
      m,
      getNode(srcChain).networkId
    )
  }

  function transferCreate(sender, receiver, receiverKp, fromPub, fromPriv, chainId, amount){
    const m = Pact.lang.mkMeta(sender, chainId, gasPrice, transferGasLimit, createTime(), 28800);
    const kp = fromPub.map(pub => {
      return {publicKey: pub, secretKey: fromPriv, clist: [{name: "coin.GAS", args: []}, {name: "coin.TRANSFER", args: [sender, receiver, Number(amount)]}]}
    })
    let pactCode = `(coin.transfer-create ${JSON.stringify(sender)} ${JSON.stringify(receiver)} (read-keyset "ks") ${convertDecimal(amount)})`;
    if (!validateKeyset(receiverKp) && receiverKp.keysetref){
      pactCode = `(coin.transfer-create ${JSON.stringify(sender)} ${JSON.stringify(receiver)} (keyset-ref-guard ${JSON.stringify(receiverKp.keysetref)}) ${convertDecimal(amount)})`;
    }
    return Pact.simple.exec.createCommand(
        kp,
        JSON.stringify(new Date()),
        pactCode,
        {"ks": receiverKp},
        m,
        getNode(chainId).networkId
      )
  }

  const signCmd = function(unSigned, sig){
    let signed = Object.assign(unSigned);
    signed.cmds[0].sigs = [{"sig": sig}]
    return signed;
  }

  const getInputs = function (){
    return {
      fromAccount: document.getElementById("fromAccount").value,
      fromChainId: document.getElementById("fromChainId").value,
      fromPublicKey: document.getElementById("publicKey").value,
      toAccount: document.getElementById("toAccount").value,
      toChainId: document.getElementById("toChainId").value,
      toGuard: readKeyset(),
      amount: document.getElementById("amount").value,
      signature: document.getElementById("signature").value
    }
  }

  const getTransferCmd = function () {
    let {fromAccount, fromChainId, fromPublicKey, toAccount, toChainId, toGuard, amount, signature} = getInputs();
    let privKey = signature.length === 128 && isPriv(signature)
      ? signature.slice(0,64)
      : signature.length === 64
        ? signature
        : null
    if (isCrossChain(fromChainId, toChainId)) {
      return crossTransfer(fromAccount, toAccount, toGuard, fromChainId, toChainId, amount, fromPublicKey, privKey);
    }
    else return transferCreate(fromAccount, toAccount, toGuard, fromPublicKey, privKey, fromChainId, amount)
  }

  const readKeyset = function(){
    if (document.getElementById("receiver-keyset-fixed").value) {
      return JSON.parse(document.getElementById("receiver-keyset-fixed").value);
    } else if(document.getElementById("basic").classList.contains( 'active' )){
          if (document.getElementById("basicPublicKey").value.length !== 64) return null
      else {
        return {
           "keys": [document.getElementById("basicPublicKey").value],
           "pred": document.getElementById("basicPredicate").value
        }
      }
    } else if (document.getElementById("custom").classList.contains( 'active' )){
      return JSON.parse(document.getElementById("custom-guard").value)
    } else if (document.getElementById("upload").classList.contains( 'active' )){
      return document.getElementById("toPubFile").value
    } else return null;
  }

  const openAccordion  = function (){
    let title = document.getElementById("sign-button");
    let content = document.getElementById("hash-content");
    title.classList.add('active')
    content.classList.add('active')
  }

  const disable = function (field){
    document.getElementById(field).disabled = true;
  }

  const enable = function (field){
    document.getElementById(field).disabled = false;
  }

  const disableFields = function(){
    let fields = ['fromAccount','toAccount', 'receiver-select', 'amount',
    ,'basicPublicKey','custom-guard']
    fields.forEach(field => disable(field))
    let dropdowns = ["predicateDropdown", "fromIdDropdown", "toIdDropdown"]
    dropdowns.forEach(dropdown => {
      document.getElementById(dropdown).classList.add('disabled')
    })
  }

  const enableFields = function (field){
    let fields = ['fromAccount','fromChainId','toAccount','toChainId', 'receiver-select', 'amount'
    ,'basicPublicKey','basicPredicate','custom-guard']
    fields.forEach(field => enable(field))
    let dropdowns = ["predicateDropdown", "fromIdDropdown", "toIdDropdown"]
    dropdowns.forEach(dropdown => {
      document.getElementById(dropdown).classList.remove('disabled')
    })
  }

  const closeAccordion  = function (){
    let title = document.getElementById("sign-button");
    let content = document.getElementById("hash-content");
    title.classList.remove('active')
    content.classList.remove('active')
    document.getElementById("hash-string").innerText = "";
    document.getElementById("cmd").value = null;
  }

  const getHash = function(){
    document.getElementById("signature").value = ""
    let title = document.getElementById("sign-button");
    cmd = getTransferCmd()
    document.getElementById("hash-string").innerText = "";
    document.getElementById("cmd").value = null;
    document.getElementById("hash-string").innerText = cmd.cmds[0].hash
    document.getElementById("cmd").value = cmd;
    openAccordion();
  }



  const showHash = function () {
    disableFields()
    getHash();
  }

  const isCrossChain = function (from, to) {
    if (from!== to){
      return true;
    } else return false;
  }

</script>
</head>
<body>
    <div id="main">
        <div class="ui container">
            <a href="/"><img src="./kadena-logo.png" class="center" style="height:70px"></a>

            <h1>Kadena Coin Transfer</h1>
            <div id="kadena-warning" class="ui warning message">
              <i class="close icon"></i>
                <div class="header">
                    Caution
                </div>
                <p>
                Blockchain transactions are <b>irreversable</b>. If you make a mistake,
                your coins <b>may not be recoverable</b>. Before you transfer large sums,
                it is always best to do a small test transaction first and then
                send those coins back to the sender to verify that the receiver's
                account works as expected.
                </p>
            </div>
            <form id ="kadena-form" class="ui form" autocomplete="off">
              <div class="field">
                <label>Network</label>
                <div class="ui floating labeled icon dropdown button">
                  <i class="sync icon"></i>
                  <span id="network" class="text">Mainnet</span>
                  <div class="menu">
                                        <!-- <div class="header">
                      Add a custom node
                    </div> -->
                    <!-- <div class="ui left icon input">
                      <i class="search icon"></i>
                      <input placeholder="Enter your node...">
                    </div>
                    <div class="divider"></div> -->

                    <div id="network-0" class="item">
                      <span>Mainnet</span>
                    </div>
                    <div id="network-1" class="item">
                      <span>Testnet</span>
                    </div>
                  </div>
                </div>
              </div>
                <div class="field">
                  <label>Sender</label>
                  <div class="ui right action left input">
                    <input type="text" id="fromAccount" placeholder="Enter Account Name of the sender">
                    <div id="fromIdDropdown" class="ui basic floating compact selection dropdown button chain">
                      <input type="hidden" value="0" id="fromChainId">
                      <div class="text">Chain 0</div>
                      <i class="dropdown icon"></i>
                      <div class="menu">
                        <div class="item" data-value="0">Chain 0</div>
                        <div class="item" data-value="1">Chain 1</div>
                        <div class="item" data-value="2">Chain 2</div>
                        <div class="item" data-value="3">Chain 3</div>
                        <div class="item" data-value="4">Chain 4</div>
                        <div class="item" data-value="5">Chain 5</div>
                        <div class="item" data-value="6">Chain 6</div>
                        <div class="item" data-value="7">Chain 7</div>
                        <div class="item" data-value="8">Chain 8</div>
                        <div class="item" data-value="9">Chain 9</div>
                        <div class="item" data-value="10">Chain 10</div>
                        <div class="item" data-value="11">Chain 11</div>
                        <div class="item" data-value="12">Chain 12</div>
                        <div class="item" data-value="13">Chain 13</div>
                        <div class="item" data-value="14">Chain 14</div>
                        <div class="item" data-value="15">Chain 15</div>
                        <div class="item" data-value="16">Chain 16</div>
                        <div class="item" data-value="17">Chain 17</div>
                        <div class="item" data-value="18">Chain 18</div>
                        <div class="item" data-value="19">Chain 19</div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="field">
                  <label>Receiver</label>
                  <div class="ui right action left input">
                    <input id="toAccount" type="text" placeholder="Enter Account Name of the receiver">
                    <div id="toIdDropdown" class="ui basic floating compact selection dropdown button chain">
                      <input class="default text" value="0" type="hidden" id="toChainId">
                      <div class="text">Chain 0</div>
                      <i class="dropdown icon"></i>
                        <div class="menu">
                          <div class="item" data-value="0">Chain 0</div>
                          <div class="item" data-value="1">Chain 1</div>
                          <div class="item" data-value="2">Chain 2</div>
                          <div class="item" data-value="3">Chain 3</div>
                          <div class="item" data-value="4">Chain 4</div>
                          <div class="item" data-value="5">Chain 5</div>
                          <div class="item" data-value="6">Chain 6</div>
                          <div class="item" data-value="7">Chain 7</div>
                          <div class="item" data-value="8">Chain 8</div>
                          <div class="item" data-value="9">Chain 9</div>
                          <div class="item" data-value="10">Chain 10</div>
                          <div class="item" data-value="11">Chain 11</div>
                          <div class="item" data-value="12">Chain 12</div>
                          <div class="item" data-value="13">Chain 13</div>
                          <div class="item" data-value="14">Chain 14</div>
                          <div class="item" data-value="15">Chain 15</div>
                          <div class="item" data-value="16">Chain 16</div>
                          <div class="item" data-value="17">Chain 17</div>
                          <div class="item" data-value="18">Chain 18</div>
                          <div class="item" data-value="19">Chain 19</div>
                        </div>
                    </div>
                  </div>
                </div>
              <div id="receiver-keyset" class="field" hidden>
                <label>Receiver Keyset</label>
              <div id="receiver-select" class="content" hidden>
                <div class="ui secondary pointing menu">
                  <a class="item active" id="basic">
                    Basic
                  </a>
                  <a class="item" id="custom">
                    Custom
                  </a>
                  <!-- <a class="item" id="upload">
                    Upload
                  </a> -->
                </div>
                <div class="ui segment" id="keyset">
                  <div id="basic-input" class="field">
                    <label>Public Key</label>
                    <div class="ui right action left input">
                      <input id="basicPublicKey" type="text" placeholder="Enter Receiver Keyset">
                      <div id="predicateDropdown" class="ui basic floating compact selection dropdown button chain">
                        <input id="basicPredicate" type="hidden" value="keys-all" id="pred">
                        <div class="text">keys-all</div>
                        <i class="dropdown icon"></i>
                          <div class="menu">
                            <div class="item" data-value="keys-all">keys-all</div>
                            <div class="item" data-value="keys-any">keys-any</div>
                          </div>
                      </div>
                    </div>
                  </div>
                  <div id="custom-input" class="field" hidden>
                    <label>Create a Multi-Sig Keyset.</label>
                    <textarea id="custom-guard">{"pred": "", "keys": []}</textarea>
                  </div>
                  <!-- <div id="upload-input" class="field" hidden>
                    <label>Upload KDA file</label>
                    <div>
                      <input id="to-pub-file" type="file" class="ui primary button" onchange="toPubLoad()"/>
                    </div>
                  </div> -->
                </div>
              </div>
              <div id="receiver-exist" class="ui segment" hidden>
                <textArea id="receiver-keyset-fixed" readonly></textArea>
              </div>
            </div>
            <div class="field">
              <label>Amount</label>
              <input type="text" id="amount" name="amount" placeholder="Enter Amount To Transfer">
            </div>
              <div class="field">
                  <label>Sign</label>
                  <div class="ui accordion">
                    <div class="title" id="sign-button">
                      <i class="dropdown icon"></i>
                      Get Hash (Use with signature)
                    </div>
                    <div class="content" id="hash-content">
                      <div class="ui message">
                        <p style="font-weight:bold;" id="hash-string"></p>
                      </div>
                    </div>
              </div>
              <br/>
              <div class="field">
                <input type="text" id="signature" placeholder="Enter Private Key or Signature">
              </div>
              <div id="submit-button" class="ui submit primary button">Make Transfer</div>
              <div id="reset-button" class="ui button">Reset</div>
          <div id="acct-err" class="ui center error message" hidden></div>
          <div id="cmd"></div>
          <div id="xchain-box" class="ui compact message hidden" hidden>
            <div class="header" id="x-header"> </div>
            <p class="header" id="x-message"></p>
          </div>
          <div id="status-box" class="ui compact message result hidden">
            <div class="header" id="status-header"></div>
            <p id="status-message"></p>
            <p id="status-lookup">Check your transaction: <br/><a id="status-link"/></p>
          </div>
          <br/>
          <div type="text" id="publicKey" hidden />
          </div>
        </form>

    </div>
</body>
<style>
  .container {
    margin-top: 40px;
    text-align: center;
  }

  #kadena-form {
    margin: auto;
    text-align: center;
    width: 400px;
  }
  a:hover {
   cursor:pointer;
  }

</style>
</html>
